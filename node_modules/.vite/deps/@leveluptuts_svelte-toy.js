import {
  require_lodash
} from "./chunk-RWVEZNZC.js";
import {
  slide
} from "./chunk-UYDFXFL5.js";
import "./chunk-M6MB33T7.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  prop_dev,
  safe_not_equal,
  set_data_dev,
  set_store_value,
  space,
  subscribe,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots,
  validate_store
} from "./chunk-RVLVW3YK.js";
import {
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/@leveluptuts/svelte-toy/Row.svelte
var import_lodash = __toESM(require_lodash());
var { Object: Object_1 } = globals;
var file = "node_modules/@leveluptuts/svelte-toy/Row.svelte";
function add_css(target) {
  append_styles(target, "svelte-14o7d3t", ".key.svelte-14o7d3t{font-size:0.6rem;color:var(--toy-key-color);opacity:0.9}.st-container.svelte-14o7d3t{display:flex;align-items:baseline;justify-content:flex-start;margin-bottom:2px}input.svelte-14o7d3t{display:inline;padding:0 3px;margin:0 4px;margin-left:2px;font-size:0.6rem;font-family:'MonoLisa', monospace;flex-grow:0;color:var(--toy-color-int);color:var(--toy-value-color);border:0;border-radius:1px;outline-offset:1px;background:var(--toy-background-int)}input.svelte-14o7d3t::-webkit-outer-spin-button,input.svelte-14o7d3t::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}input[type='number'].svelte-14o7d3t{-moz-appearance:textfield}[type='number'].svelte-14o7d3t{width:80px}.nested.svelte-14o7d3t{margin-left:15px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUm93LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFpRkMsbUJBQUssQ0FDSixTQUFTLENBQUUsTUFBTSxDQUNqQixLQUFLLENBQUUsSUFBSSxlQUFlLENBQUMsQ0FDM0IsT0FBTyxDQUFFLEdBQ1YsQ0FFQSw0QkFBYyxDQUNiLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLFFBQVEsQ0FDckIsZUFBZSxDQUFFLFVBQVUsQ0FDM0IsYUFBYSxDQUFFLEdBQ2hCLENBRUEsb0JBQU0sQ0FDTCxPQUFPLENBQUUsTUFBTSxDQUVmLE9BQU8sQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUNkLE1BQU0sQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUNiLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLFNBQVMsQ0FBRSxNQUFNLENBQ2pCLFdBQVcsQ0FBRSxVQUFVLENBQUMsQ0FBQyxTQUFTLENBQ2xDLFNBQVMsQ0FBRSxDQUFDLENBQ1osS0FBSyxDQUFFLElBQUksZUFBZSxDQUFDLENBQzNCLEtBQUssQ0FBRSxJQUFJLGlCQUFpQixDQUFDLENBQzdCLE1BQU0sQ0FBRSxDQUFDLENBQ1QsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsY0FBYyxDQUFFLEdBQUcsQ0FDbkIsVUFBVSxDQUFFLElBQUksb0JBQW9CLENBQ3JDLENBR0Esb0JBQUssMkJBQTJCLENBQ2hDLG9CQUFLLDJCQUE0QixDQUNoQyxrQkFBa0IsQ0FBRSxJQUFJLENBQ3hCLE1BQU0sQ0FBRSxDQUNULENBR0EsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLGdCQUFFLENBQ3BCLGVBQWUsQ0FBRSxTQUNsQixDQUVBLENBQUMsSUFBSSxDQUFDLFFBQVEsZ0JBQUUsQ0FDZixLQUFLLENBQUUsSUFDUixDQUVBLHNCQUFRLENBQ1AsV0FBVyxDQUFFLElBQ2QiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiUm93LnN2ZWx0ZSJdfQ== */");
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i][0];
  child_ctx[11] = list[i][1];
  return child_ctx;
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  child_ctx[13] = i;
  return child_ctx;
}
function create_if_block(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*value*/
    ctx2[1] === "object")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(24:0) {#if value !== null}",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let label_1;
  let t;
  let if_block0 = (
    /*label*/
    ctx[4] && create_if_block_8(ctx)
  );
  function select_block_type_2(ctx2, dirty) {
    if (typeof /*value*/
    ctx2[1] === "string")
      return create_if_block_5;
    if (typeof /*value*/
    ctx2[1] === "boolean")
      return create_if_block_6;
    if (typeof /*value*/
    ctx2[1] === "number")
      return create_if_block_7;
  }
  let current_block_type = select_block_type_2(ctx, -1);
  let if_block1 = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      label_1 = element("label");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { class: true, for: true });
      var label_1_nodes = children(label_1);
      if (if_block0)
        if_block0.l(label_1_nodes);
      t = claim_space(label_1_nodes);
      if (if_block1)
        if_block1.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label_1, "class", "st-container svelte-14o7d3t");
      attr_dev(
        label_1,
        "for",
        /*path*/
        ctx[3]
      );
      add_location(label_1, file, 51, 2, 1197);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      if (if_block0)
        if_block0.m(label_1, null);
      append_hydration_dev(label_1, t);
      if (if_block1)
        if_block1.m(label_1, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*label*/
        ctx2[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          if_block0.m(label_1, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_2(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if (if_block1)
          if_block1.d(1);
        if_block1 = current_block_type && current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(label_1, null);
        }
      }
      if (dirty & /*path*/
      8) {
        attr_dev(
          label_1,
          "for",
          /*path*/
          ctx2[3]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (if_block0)
        if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(50:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2, create_else_block];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty & /*value*/
    2)
      show_if = null;
    if (show_if == null)
      show_if = !!Array.isArray(
        /*value*/
        ctx2[1]
      );
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(25:1) {#if typeof value === 'object'}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let span;
  let t0;
  let t1_value = ":";
  let t1;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text(
        /*key*/
        ctx[0]
      );
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*key*/
        ctx[0]
      );
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "key svelte-14o7d3t");
      add_location(span, file, 53, 4, 1256);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*key*/
      1)
        set_data_dev(
          t0,
          /*key*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(53:3) {#if label}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { id: true, type: true, class: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        input,
        "id",
        /*path*/
        ctx[3]
      );
      attr_dev(input, "type", "number");
      input.value = /*value*/
      ctx[1];
      attr_dev(input, "class", "svelte-14o7d3t");
      add_location(input, file, 67, 4, 1656);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (!mounted) {
        dispose = listen_dev(
          input,
          "change",
          /*change_handler_1*/
          ctx[9],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*path*/
      8) {
        attr_dev(
          input,
          "id",
          /*path*/
          ctx2[3]
        );
      }
      if (dirty & /*value*/
      2 && input.value !== /*value*/
      ctx2[1]) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(67:39) ",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { id: true, type: true, class: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        input,
        "id",
        /*path*/
        ctx[3]
      );
      attr_dev(input, "type", "checkbox");
      input.checked = /*value*/
      ctx[1];
      attr_dev(input, "class", "svelte-14o7d3t");
      add_location(input, file, 58, 4, 1471);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (!mounted) {
        dispose = listen_dev(
          input,
          "change",
          /*change_handler*/
          ctx[8],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*path*/
      8) {
        attr_dev(
          input,
          "id",
          /*path*/
          ctx2[3]
        );
      }
      if (dirty & /*value*/
      2) {
        prop_dev(
          input,
          "checked",
          /*value*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(58:40) ",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { id: true, type: true, class: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        input,
        "id",
        /*path*/
        ctx[3]
      );
      attr_dev(input, "type", "text");
      input.value = /*value*/
      ctx[1];
      attr_dev(input, "class", "svelte-14o7d3t");
      add_location(input, file, 56, 4, 1340);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (!mounted) {
        dispose = listen_dev(
          input,
          "input",
          /*input_handler*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*path*/
      8) {
        attr_dev(
          input,
          "id",
          /*path*/
          ctx2[3]
        );
      }
      if (dirty & /*value*/
      2 && input.value !== /*value*/
      ctx2[1]) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(56:3) {#if typeof value === 'string'}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let t;
  let div;
  let current;
  let if_block = (
    /*label*/
    ctx[4] && create_if_block_4(ctx)
  );
  let each_value_1 = Object.entries(
    /*value*/
    ctx[1]
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "nested svelte-14o7d3t");
      add_location(div, file, 43, 3, 908);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*label*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*Object, value, store, path*/
      14) {
        each_value_1 = Object.entries(
          /*value*/
          ctx2[1]
        );
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(40:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let t;
  let each_1_anchor;
  let current;
  let if_block = (
    /*label*/
    ctx[4] && create_if_block_3(ctx)
  );
  let each_value = (
    /*value*/
    ctx[1]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*label*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*key, value, store, path*/
      15) {
        each_value = /*value*/
        ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(26:2) {#if Array.isArray(value)}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let span;
  let t0;
  let t1_value = ":";
  let t1;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text(
        /*key*/
        ctx[0]
      );
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*key*/
        ctx[0]
      );
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "key svelte-14o7d3t");
      add_location(span, file, 41, 4, 860);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*key*/
      1)
        set_data_dev(
          t0,
          /*key*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(41:3) {#if label}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let row;
  let current;
  row = new Row({
    props: {
      key: (
        /*nestedKey*/
        ctx[14]
      ),
      value: (
        /*nestedValue*/
        ctx[11]
      ),
      store: (
        /*store*/
        ctx[2]
      ),
      path: (
        /*path*/
        ctx[3] + "." + /*nestedKey*/
        ctx[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(row.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(row.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const row_changes = {};
      if (dirty & /*value*/
      2)
        row_changes.key = /*nestedKey*/
        ctx2[14];
      if (dirty & /*value*/
      2)
        row_changes.value = /*nestedValue*/
        ctx2[11];
      if (dirty & /*store*/
      4)
        row_changes.store = /*store*/
        ctx2[2];
      if (dirty & /*path, value*/
      10)
        row_changes.path = /*path*/
        ctx2[3] + "." + /*nestedKey*/
        ctx2[14];
      row.$set(row_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(row, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(45:4) {#each Object.entries(value) as [nestedKey, nestedValue]}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let span;
  let t0;
  let t1_value = ":";
  let t1;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text(
        /*key*/
        ctx[0]
      );
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*key*/
        ctx[0]
      );
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "key svelte-14o7d3t");
      add_location(span, file, 27, 4, 589);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*key*/
      1)
        set_data_dev(
          t0,
          /*key*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(27:3) {#if label}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let row;
  let current;
  row = new Row({
    props: {
      label: false,
      key: (
        /*key*/
        ctx[0]
      ),
      value: (
        /*nestedValue*/
        ctx[11]
      ),
      store: (
        /*store*/
        ctx[2]
      ),
      path: (
        /*path*/
        ctx[3] + "[" + /*index*/
        ctx[13] + "]"
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(row.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(row.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const row_changes = {};
      if (dirty & /*key*/
      1)
        row_changes.key = /*key*/
        ctx2[0];
      if (dirty & /*value*/
      2)
        row_changes.value = /*nestedValue*/
        ctx2[11];
      if (dirty & /*store*/
      4)
        row_changes.store = /*store*/
        ctx2[2];
      if (dirty & /*path*/
      8)
        row_changes.path = /*path*/
        ctx2[3] + "[" + /*index*/
        ctx2[13] + "]";
      row.$set(row_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(row, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(31:3) {#each value as nestedValue, index}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*value*/
    ctx[1] !== null && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*value*/
        ctx2[1] !== null
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*value*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, ($$value) => $$invalidate(10, $store = $$value)), store);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Row", slots, []);
  let { key } = $$props;
  let { value } = $$props;
  let { store } = $$props;
  validate_store(store, "store");
  $$subscribe_store();
  let { path } = $$props;
  let { simple = false } = $$props;
  let { label = true } = $$props;
  function updateStore(value2) {
    if (simple) {
      set_store_value(store, $store = value2, $store);
    } else {
      store.update((u) => {
        let newData = {
          ...u
          // If store is complex (array, object)
        };
        (0, import_lodash.default)(newData, path, value2);
        return newData;
      });
    }
  }
  $$self.$$.on_mount.push(function() {
    if (key === void 0 && !("key" in $$props || $$self.$$.bound[$$self.$$.props["key"]])) {
      console.warn("<Row> was created without expected prop 'key'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Row> was created without expected prop 'value'");
    }
    if (store === void 0 && !("store" in $$props || $$self.$$.bound[$$self.$$.props["store"]])) {
      console.warn("<Row> was created without expected prop 'store'");
    }
    if (path === void 0 && !("path" in $$props || $$self.$$.bound[$$self.$$.props["path"]])) {
      console.warn("<Row> was created without expected prop 'path'");
    }
  });
  const writable_props = ["key", "value", "store", "path", "simple", "label"];
  Object_1.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Row> was created with unknown prop '${key2}'`);
  });
  const input_handler = (e) => updateStore(e.target.value);
  const change_handler = (e) => {
    updateStore(e.target.checked);
  };
  const change_handler_1 = (e) => {
    updateStore(parseFloat(e.target.value));
  };
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(0, key = $$props2.key);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(2, store = $$props2.store));
    if ("path" in $$props2)
      $$invalidate(3, path = $$props2.path);
    if ("simple" in $$props2)
      $$invalidate(6, simple = $$props2.simple);
    if ("label" in $$props2)
      $$invalidate(4, label = $$props2.label);
  };
  $$self.$capture_state = () => ({
    set: import_lodash.default,
    key,
    value,
    store,
    path,
    simple,
    label,
    updateStore,
    $store
  });
  $$self.$inject_state = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(0, key = $$props2.key);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(2, store = $$props2.store));
    if ("path" in $$props2)
      $$invalidate(3, path = $$props2.path);
    if ("simple" in $$props2)
      $$invalidate(6, simple = $$props2.simple);
    if ("label" in $$props2)
      $$invalidate(4, label = $$props2.label);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    key,
    value,
    store,
    path,
    label,
    updateStore,
    simple,
    input_handler,
    change_handler,
    change_handler_1
  ];
}
var Row = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        key: 0,
        value: 1,
        store: 2,
        path: 3,
        simple: 6,
        label: 4
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Row",
      options,
      id: create_fragment.name
    });
  }
  get key() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get store() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set store(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get path() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get simple() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set simple(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Row_default = Row;

// node_modules/@leveluptuts/svelte-toy/ToyGroup.svelte
var { Object: Object_12 } = globals;
var file2 = "node_modules/@leveluptuts/svelte-toy/ToyGroup.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1603zms", 'div.svelte-1603zms.svelte-1603zms{margin-bottom:5px}.state-mang-data.svelte-1603zms.svelte-1603zms{padding:10px}h4.svelte-1603zms.svelte-1603zms{border-bottom:solid 1px var(--toy-lowlight);border-top:solid 1px var(--toy-highlight);box-shadow:var(--level-2, 0 2px 3px rgba(0, 0, 0, 0.1), 0 1px 5px rgba(0, 0, 0, 0.13));font-family:"MonoLisa", monospace;text-transform:capitalize;padding:4px 6px;cursor:pointer;font-size:var(--toy-heading-font-size, 12px);margin:0;background:var(--toy-header-bg);color:var(--toy-header-color, --toy-color)}h4.svelte-1603zms span.svelte-1603zms{display:inline-block;font-size:10px;transform:rotate(-90deg);transition:0.2s transform var(--ease_in_out_quint)}h4.isOpen.svelte-1603zms span.svelte-1603zms{transform:rotate(0turn)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG95R3JvdXAuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTBCTyxpQ0FBSSxDQUNULGFBQWEsQ0FBRSxHQUNqQixDQUVBLDhDQUFpQixDQUNmLE9BQU8sQ0FBRSxJQUNYLENBRUEsZ0NBQUcsQ0FDRCxhQUFhLENBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLGNBQWMsQ0FBQyxDQUM1QyxVQUFVLENBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxDQUMxQyxVQUFVLENBQUUsSUFBSSxTQUFTLENBQUMsNERBQTRELENBQUMsQ0FDdkYsV0FBVyxDQUFFLFVBQVUsQ0FBQyxDQUFDLFNBQVMsQ0FDbEMsY0FBYyxDQUFFLFVBQVUsQ0FDMUIsT0FBTyxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQ2hCLE1BQU0sQ0FBRSxPQUFPLENBQ2YsU0FBUyxDQUFFLElBQUksdUJBQXVCLENBQUMsS0FBSyxDQUFDLENBQzdDLE1BQU0sQ0FBRSxDQUFDLENBQ1QsVUFBVSxDQUFFLElBQUksZUFBZSxDQUFDLENBQ2hDLEtBQUssQ0FBRSxJQUFJLGtCQUFrQixDQUFDLFlBQVksQ0FDNUMsQ0FDQSxpQkFBRSxDQUFDLG1CQUFLLENBQ04sT0FBTyxDQUFFLFlBQVksQ0FDckIsU0FBUyxDQUFFLElBQUksQ0FDZixTQUFTLENBQUUsT0FBTyxNQUFNLENBQUMsQ0FDekIsVUFBVSxDQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxtQkFBbUIsQ0FDcEQsQ0FDQSxFQUFFLHNCQUFPLENBQUMsbUJBQUssQ0FDYixTQUFTLENBQUUsT0FBTyxLQUFLLENBQ3pCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlRveUdyb3VwLnN2ZWx0ZSJdfQ== */');
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i][0];
  child_ctx[6] = list[i][1];
  return child_ctx;
}
function create_if_block2(ctx) {
  let h4;
  let span;
  let t0;
  let t1;
  let t2;
  let t3;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block_12(ctx)
  );
  const block = {
    c: function create() {
      h4 = element("h4");
      span = element("span");
      t0 = text("▼");
      t1 = space();
      t2 = text(
        /*label*/
        ctx[2]
      );
      t3 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      h4 = claim_element(nodes, "H4", { class: true });
      var h4_nodes = children(h4);
      span = claim_element(h4_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "▼");
      span_nodes.forEach(detach_dev);
      t1 = claim_space(h4_nodes);
      t2 = claim_text(
        h4_nodes,
        /*label*/
        ctx[2]
      );
      h4_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "svelte-1603zms");
      add_location(span, file2, 9, 2, 219);
      attr_dev(h4, "class", "svelte-1603zms");
      toggle_class(
        h4,
        "isOpen",
        /*isOpen*/
        ctx[0]
      );
      add_location(h4, file2, 8, 1, 163);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h4, anchor);
      append_hydration_dev(h4, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(h4, t1);
      append_hydration_dev(h4, t2);
      insert_hydration_dev(target, t3, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          h4,
          "click",
          /*click_handler*/
          ctx[4],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*label*/
      4)
        set_data_dev(
          t2,
          /*label*/
          ctx2[2]
        );
      if (!current || dirty & /*isOpen*/
      1) {
        toggle_class(
          h4,
          "isOpen",
          /*isOpen*/
          ctx2[0]
        );
      }
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h4);
      if (detaching)
        detach_dev(t3);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(8:0) {#if $store}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_transition;
  let current;
  const if_block_creators = [create_if_block_22, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*$store*/
    ctx2[3] === "object")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "state-mang-data svelte-1603zms");
      add_location(div, file2, 14, 2, 268);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, {}, true);
        div_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, {}, false);
      div_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(14:1) {#if isOpen}",
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let row;
  let current;
  row = new Row_default({
    props: {
      key: (
        /*label*/
        ctx[2]
      ),
      value: (
        /*$store*/
        ctx[3]
      ),
      store: (
        /*store*/
        ctx[1]
      ),
      path: (
        /*label*/
        ctx[2]
      ),
      simple: true,
      label: false
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(row.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(row.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const row_changes = {};
      if (dirty & /*label*/
      4)
        row_changes.key = /*label*/
        ctx2[2];
      if (dirty & /*$store*/
      8)
        row_changes.value = /*$store*/
        ctx2[3];
      if (dirty & /*store*/
      2)
        row_changes.store = /*store*/
        ctx2[1];
      if (dirty & /*label*/
      4)
        row_changes.path = /*label*/
        ctx2[2];
      row.$set(row_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(row, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(20:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let each_1_anchor;
  let current;
  let each_value = Object.entries(
    /*$store*/
    ctx[3]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*Object, $store, store*/
      10) {
        each_value = Object.entries(
          /*$store*/
          ctx2[3]
        );
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(16:3) {#if typeof $store === 'object'}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let row;
  let current;
  row = new Row_default({
    props: {
      key: (
        /*key*/
        ctx[5]
      ),
      value: (
        /*value*/
        ctx[6]
      ),
      store: (
        /*store*/
        ctx[1]
      ),
      path: (
        /*key*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(row.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(row.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const row_changes = {};
      if (dirty & /*$store*/
      8)
        row_changes.key = /*key*/
        ctx2[5];
      if (dirty & /*$store*/
      8)
        row_changes.value = /*value*/
        ctx2[6];
      if (dirty & /*store*/
      2)
        row_changes.store = /*store*/
        ctx2[1];
      if (dirty & /*$store*/
      8)
        row_changes.path = /*key*/
        ctx2[5];
      row.$set(row_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(row, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(17:4) {#each Object.entries($store) as [key, value]}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$store*/
    ctx[3] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$store*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$store*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, ($$value) => $$invalidate(3, $store = $$value)), store);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToyGroup", slots, []);
  let { store } = $$props;
  validate_store(store, "store");
  $$subscribe_store();
  let { label } = $$props;
  let { isOpen } = $$props;
  $$self.$$.on_mount.push(function() {
    if (store === void 0 && !("store" in $$props || $$self.$$.bound[$$self.$$.props["store"]])) {
      console.warn("<ToyGroup> was created without expected prop 'store'");
    }
    if (label === void 0 && !("label" in $$props || $$self.$$.bound[$$self.$$.props["label"]])) {
      console.warn("<ToyGroup> was created without expected prop 'label'");
    }
    if (isOpen === void 0 && !("isOpen" in $$props || $$self.$$.bound[$$self.$$.props["isOpen"]])) {
      console.warn("<ToyGroup> was created without expected prop 'isOpen'");
    }
  });
  const writable_props = ["store", "label", "isOpen"];
  Object_12.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ToyGroup> was created with unknown prop '${key}'`);
  });
  const click_handler = () => $$invalidate(0, isOpen = !isOpen);
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(1, store = $$props2.store));
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("isOpen" in $$props2)
      $$invalidate(0, isOpen = $$props2.isOpen);
  };
  $$self.$capture_state = () => ({ slide, Row: Row_default, store, label, isOpen, $store });
  $$self.$inject_state = ($$props2) => {
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(1, store = $$props2.store));
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("isOpen" in $$props2)
      $$invalidate(0, isOpen = $$props2.isOpen);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [isOpen, store, label, $store, click_handler];
}
var ToyGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { store: 1, label: 2, isOpen: 0 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToyGroup",
      options,
      id: create_fragment2.name
    });
  }
  get store() {
    throw new Error("<ToyGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set store(value) {
    throw new Error("<ToyGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ToyGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ToyGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<ToyGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<ToyGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToyGroup_default = ToyGroup;

// node_modules/@leveluptuts/svelte-side-menu/dist/SideMenu.svelte
var file3 = "node_modules/@leveluptuts/svelte-side-menu/dist/SideMenu.svelte";
function add_css3(target) {
  append_styles(target, "svelte-j9woxb", ".side-menu.svelte-j9woxb{--toy-highlight:hsla(0, 0%, 100%, 1);--toy-top-position:var(--sm-top, 0);--toy-color-int:var(--toy-color, hsla(0, 0%, 20%, 1));--toy-background-int:var(--toy-bg, white);--toy-header-bg:hsla(0, 0%, 95%, 1);font-family:var(--toy-font-family, sans-serif);transition:transform 0.2s var(--ease_in_out_quint, cubic-bezier(0.83, 0, 0.17, 1));transform:translate3d(100%, 0, 0);position:fixed;top:var(--sm-top);bottom:100vh;right:0;width:var(--toy-width, 300px);z-index:var(--toy-z, 2001);&.dark {\n			--toy-color: hsla(0, 0%, 80%, 1);\n			--toy-header-color: hsla(0, 0%, 80%, 1);\n			--toy-background-int: hsla(241, 6%, 15%, 1);\n			--toy-nub-bg: var(--toy-background-int);\n			--toy-highlight: hsla(0, 0%, 25%, 1);\n			--toy-lowlight: hsla(0, 0%, 5%, 1);\n			--toy-header-bg: hsla(0, 0%, 10%, 1);\n		};&.active {\n			transform: translate3d(0, 0, 0) scale(1.05);\n		};& .nub {\n			appearance: none;\n			border-bottom: solid 1px var(--toy-lowlight);\n			border-right: solid 1px var(--toy-lowlight);\n			border-top: solid 1px var(--toy-highlight);\n			border-left: solid 1px var(--toy-highlight);\n			border-radius: 5px 0 0 5px;\n			box-shadow: var(\n				--level-4,\n				-6px 14px 28px rgba(0, 0, 0, 0.1),\n				-6px 10px 10px rgba(0, 0, 0, 0.12)\n			);\n			position: absolute;\n			padding: 10px;\n			right: 100%;\n			top: 20px;\n			background: var(--toy-nub-bg, var(--toy-header-bg));\n			cursor: pointer;\n		}}.side-menu-content.svelte-j9woxb{border-left:solid 1px var(--toy-highlight);box-shadow:var(--level-4, 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22));background:var(--toy-background-int);color:var(--toy-color-int);overflow:hidden;max-height:calc(100vh - var(--toy-top-position));overflow-y:scroll;border-radius:5px 0 0 5px;padding-bottom:200px;box-sizing:border-box}h4.svelte-j9woxb{border-bottom:solid 1px var(--toy-lowlight);border-top:solid 1px var(--toy-highlight);box-shadow:var(--level-2, 0 2px 3px rgba(0, 0, 0, 0.1), 0 1px 5px rgba(0, 0, 0, 0.13));text-transform:capitalize;padding:4px 6px;cursor:pointer;font-size:var(--toy-heading-font-size, 12px);margin:0;background:var(--toy-header-bg);color:var(--toy-header-color, --toy-color)}a.svelte-j9woxb{display:block;padding:10px;color:var(--toy-color)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2lkZU1lbnUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTBDQyx3QkFBVyxDQUNWLGVBQWUsQ0FBRSxvQkFBb0IsQ0FDckMsa0JBQWtCLENBQUUsZ0JBQWdCLENBQ3BDLGVBQWUsQ0FBRSxxQ0FBcUMsQ0FDdEQsb0JBQW9CLENBQUUsb0JBQW9CLENBQzFDLGVBQWUsQ0FBRSxtQkFBbUIsQ0FDcEMsV0FBVyxDQUFFLElBQUksaUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQy9DLFVBQVUsQ0FBRSxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksbUJBQW1CLENBQUMsK0JBQStCLENBQUMsQ0FDbkYsU0FBUyxDQUFFLFlBQVksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ2xDLFFBQVEsQ0FBRSxLQUFLLENBQ2YsR0FBRyxDQUFFLElBQUksUUFBUSxDQUFDLENBQ2xCLE1BQU0sQ0FBRSxLQUFLLENBQ2IsS0FBSyxDQUFFLENBQUMsQ0FDUixLQUFLLENBQUUsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLENBQzlCLE9BQU8sQ0FBRSxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FFM0IsQ0FBQyxLQUFLLENBQUM7QUFDVCxHQUFHLFlBQVksb0JBQW9CO0FBQ25DLEdBQUcsbUJBQW1CLG9CQUFvQjtBQUMxQyxHQUFHLHFCQUFxQixzQkFBc0I7QUFDOUMsR0FBRyxhQUFhLDBCQUEwQjtBQUMxQyxHQUFHLGdCQUFnQixvQkFBb0I7QUFDdkMsR0FBRyxlQUFlLG1CQUFtQjtBQUNyQyxHQUFHLGdCQUFnQixvQkFBb0I7QUFDdkMsR0FBRSxDQUVBLENBQUMsT0FBTyxDQUFDO0FBQ1gsR0FBRyxXQUFXLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUM7QUFDOUMsR0FBRSxDQUVBLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDVCxHQUFHLFlBQVksSUFBSTtBQUNuQixHQUFHLGVBQWUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLGNBQWMsQ0FBQztBQUMvQyxHQUFHLGNBQWMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLGNBQWMsQ0FBQztBQUM5QyxHQUFHLFlBQVksS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLGVBQWUsQ0FBQztBQUM3QyxHQUFHLGFBQWEsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLGVBQWUsQ0FBQztBQUM5QyxHQUFHLGVBQWUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRztBQUM3QixHQUFHLFlBQVk7QUFDZixJQUFJLFNBQVMsQ0FBQTtBQUNiO0FBQ0E7QUFDQSxHQUFHLENBQUM7QUFDSixHQUFHLFVBQVUsUUFBUTtBQUNyQixHQUFHLFNBQVMsSUFBSTtBQUNoQixHQUFHLE9BQU8sSUFBSTtBQUNkLEdBQUcsS0FBSyxJQUFJO0FBQ1osR0FBRyxZQUFZLElBQUksWUFBWSxDQUFDLHFCQUFxQixDQUFDO0FBQ3RELEdBQUcsUUFBUSxPQUFPO0FBQ2xCLEdBQ0MsQ0FFQSxnQ0FBbUIsQ0FDbEIsV0FBVyxDQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxlQUFlLENBQUMsQ0FDM0MsVUFBVSxDQUFFLElBQUksU0FBUyxDQUFDLGlFQUFpRSxDQUFDLENBQzVGLFVBQVUsQ0FBRSxJQUFJLG9CQUFvQixDQUFDLENBQ3JDLEtBQUssQ0FBRSxJQUFJLGVBQWUsQ0FBQyxDQUMzQixRQUFRLENBQUUsTUFBTSxDQUNoQixVQUFVLENBQUUsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksa0JBQWtCLENBQUMsQ0FBQyxDQUNqRCxVQUFVLENBQUUsTUFBTSxDQUNsQixhQUFhLENBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUMxQixjQUFjLENBQUUsS0FBSyxDQUNyQixVQUFVLENBQUUsVUFDYixDQUVBLGdCQUFHLENBQ0YsYUFBYSxDQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxjQUFjLENBQUMsQ0FDNUMsVUFBVSxDQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxlQUFlLENBQUMsQ0FDMUMsVUFBVSxDQUFFLElBQUksU0FBUyxDQUFDLDREQUE0RCxDQUFDLENBQ3ZGLGNBQWMsQ0FBRSxVQUFVLENBQzFCLE9BQU8sQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUNoQixNQUFNLENBQUUsT0FBTyxDQUNmLFNBQVMsQ0FBRSxJQUFJLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxDQUM3QyxNQUFNLENBQUUsQ0FBQyxDQUNULFVBQVUsQ0FBRSxJQUFJLGVBQWUsQ0FBQyxDQUNoQyxLQUFLLENBQUUsSUFBSSxrQkFBa0IsQ0FBQyxZQUFZLENBQzNDLENBRUEsZUFBRSxDQUNELE9BQU8sQ0FBRSxLQUFLLENBQ2QsT0FBTyxDQUFFLElBQUksQ0FDYixLQUFLLENBQUUsSUFBSSxXQUFXLENBQ3ZCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlNpZGVNZW51LnN2ZWx0ZSJdfQ== */");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_else_block3(ctx) {
  let h4;
  let t_value = (
    /*link*/
    ctx[9].text + ""
  );
  let t;
  const block = {
    c: function create() {
      h4 = element("h4");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      h4 = claim_element(nodes, "H4", { class: true });
      var h4_nodes = children(h4);
      t = claim_text(h4_nodes, t_value);
      h4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h4, "class", "svelte-j9woxb");
      add_location(h4, file3, 33, 5, 675);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h4, anchor);
      append_hydration_dev(h4, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*links*/
      32 && t_value !== (t_value = /*link*/
      ctx2[9].text + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h4);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(33:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let a;
  let t_value = (
    /*link*/
    ctx[9].text + ""
  );
  let t;
  let a_href_value;
  const block = {
    c: function create() {
      a = element("a");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      t = claim_text(a_nodes, t_value);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", a_href_value = /*link*/
      ctx[9].path);
      attr_dev(a, "class", "svelte-j9woxb");
      add_location(a, file3, 31, 5, 622);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*links*/
      32 && t_value !== (t_value = /*link*/
      ctx2[9].text + ""))
        set_data_dev(t, t_value);
      if (dirty & /*links*/
      32 && a_href_value !== (a_href_value = /*link*/
      ctx2[9].path)) {
        attr_dev(a, "href", a_href_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(31:4) {#if link.path}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*link*/
      ctx2[9].path
    )
      return create_if_block3;
    return create_else_block3;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(30:3) {#each links as link}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div1;
  let button;
  let t0;
  let t1;
  let div0;
  let nav;
  let t2;
  let div1_class_value;
  let div1_style_value;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*links*/
    ctx[5]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      button = element("button");
      t0 = text(
        /*nub*/
        ctx[4]
      );
      t1 = space();
      div0 = element("div");
      nav = element("nav");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      button = claim_element(div1_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t0 = claim_text(
        button_nodes,
        /*nub*/
        ctx[4]
      );
      button_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      nav = claim_element(div0_nodes, "NAV", {});
      var nav_nodes = children(nav);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nav_nodes);
      }
      nav_nodes.forEach(detach_dev);
      t2 = claim_space(div0_nodes);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "nub");
      add_location(button, file3, 26, 1, 460);
      add_location(nav, file3, 28, 2, 566);
      attr_dev(div0, "class", "side-menu-content svelte-j9woxb");
      add_location(div0, file3, 27, 1, 532);
      attr_dev(div1, "class", div1_class_value = null_to_empty(`side-menu ${/*theme*/
      ctx[3]}`) + " svelte-j9woxb");
      attr_dev(div1, "style", div1_style_value = `--sm-top: ${/*top*/
      ctx[1]}`);
      toggle_class(
        div1,
        "active",
        /*active*/
        ctx[0]
      );
      toggle_class(
        div1,
        "right",
        /*right*/
        ctx[2]
      );
      add_location(div1, file3, 25, 0, 372);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, button);
      append_hydration_dev(button, t0);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, nav);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(nav, null);
        }
      }
      append_hydration_dev(div0, t2);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[8],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*nub*/
      16)
        set_data_dev(
          t0,
          /*nub*/
          ctx2[4]
        );
      if (dirty & /*links*/
      32) {
        each_value = /*links*/
        ctx2[5];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(nav, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*theme*/
      8 && div1_class_value !== (div1_class_value = null_to_empty(`side-menu ${/*theme*/
      ctx2[3]}`) + " svelte-j9woxb")) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*top*/
      2 && div1_style_value !== (div1_style_value = `--sm-top: ${/*top*/
      ctx2[1]}`)) {
        attr_dev(div1, "style", div1_style_value);
      }
      if (!current || dirty & /*theme, active*/
      9) {
        toggle_class(
          div1,
          "active",
          /*active*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*theme, right*/
      12) {
        toggle_class(
          div1,
          "right",
          /*right*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SideMenu", slots, ["default"]);
  let { top = `10px` } = $$props;
  let { active = false } = $$props;
  let { right = false } = $$props;
  let { theme = "" } = $$props;
  let { nub = "🚀" } = $$props;
  let { links = [
    { text: "How To Use" },
    { path: "/please", text: "Please" },
    {
      path: "/link-to",
      text: "Add `links` prop"
    },
    {
      path: "/link-to",
      text: "to populate the menu"
    }
  ] } = $$props;
  const writable_props = ["top", "active", "right", "theme", "nub", "links"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SideMenu> was created with unknown prop '${key}'`);
  });
  const click_handler = () => $$invalidate(0, active = !active);
  $$self.$$set = ($$props2) => {
    if ("top" in $$props2)
      $$invalidate(1, top = $$props2.top);
    if ("active" in $$props2)
      $$invalidate(0, active = $$props2.active);
    if ("right" in $$props2)
      $$invalidate(2, right = $$props2.right);
    if ("theme" in $$props2)
      $$invalidate(3, theme = $$props2.theme);
    if ("nub" in $$props2)
      $$invalidate(4, nub = $$props2.nub);
    if ("links" in $$props2)
      $$invalidate(5, links = $$props2.links);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ top, active, right, theme, nub, links });
  $$self.$inject_state = ($$props2) => {
    if ("top" in $$props2)
      $$invalidate(1, top = $$props2.top);
    if ("active" in $$props2)
      $$invalidate(0, active = $$props2.active);
    if ("right" in $$props2)
      $$invalidate(2, right = $$props2.right);
    if ("theme" in $$props2)
      $$invalidate(3, theme = $$props2.theme);
    if ("nub" in $$props2)
      $$invalidate(4, nub = $$props2.nub);
    if ("links" in $$props2)
      $$invalidate(5, links = $$props2.links);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [active, top, right, theme, nub, links, $$scope, slots, click_handler];
}
var SideMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        top: 1,
        active: 0,
        right: 2,
        theme: 3,
        nub: 4,
        links: 5
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SideMenu",
      options,
      id: create_fragment3.name
    });
  }
  get top() {
    throw new Error("<SideMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<SideMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<SideMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<SideMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get right() {
    throw new Error("<SideMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set right(value) {
    throw new Error("<SideMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<SideMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<SideMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nub() {
    throw new Error("<SideMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nub(value) {
    throw new Error("<SideMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get links() {
    throw new Error("<SideMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set links(value) {
    throw new Error("<SideMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SideMenu_default = SideMenu;

// node_modules/@leveluptuts/svelte-toy/Toy.svelte
var { Object: Object_13 } = globals;
var file4 = "node_modules/@leveluptuts/svelte-toy/Toy.svelte";
function add_css4(target) {
  append_styles(target, "svelte-1wrwowr", '.state-mang.svelte-1wrwowr{--toy-value-color:hsla(310, 99%, 44%, 1);--toy-key-color:hsla(208, 99%, 33%, 1)}.dark.svelte-1wrwowr{--toy-color:hsla(0, 0%, 80%, 1);--toy-background-int:hsla(241, 6%, 15%, 1);--toy-nub-bg:var(--toy-background-int);--toy-highlight:hsla(0, 0%, 25%, 1);--toy-lowlight:hsla(0, 0%, 5%, 1);--toy-header-bg:hsla(0, 0%, 10%, 1);--toy-value-color:hsla(310, 99%, 74%, 1);--toy-key-color:hsla(208, 99%, 73%, 1)}.state-mang{font-size:var(--state-tool-font-size, 14px);font-family:"MonoLisa", monospace}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG95LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF1Qk8sMEJBQVksQ0FDakIsaUJBQWlCLENBQUUsc0JBQXNCLENBQ3pDLGVBQWUsQ0FBRSxzQkFDbkIsQ0FFQSxvQkFBTSxDQUNKLFdBQVcsQ0FBRSxtQkFBbUIsQ0FDaEMsb0JBQW9CLENBQUUscUJBQXFCLENBQzNDLFlBQVksQ0FBRSx5QkFBeUIsQ0FDdkMsZUFBZSxDQUFFLG1CQUFtQixDQUNwQyxjQUFjLENBQUUsa0JBQWtCLENBQ2xDLGVBQWUsQ0FBRSxtQkFBbUIsQ0FDcEMsaUJBQWlCLENBQUUsc0JBQXNCLENBQ3pDLGVBQWUsQ0FBRSxzQkFDbkIsQ0FFUSxXQUFhLENBQ25CLFNBQVMsQ0FBRSxJQUFJLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxDQUM1QyxXQUFXLENBQUUsVUFBVSxDQUFDLENBQUMsU0FDM0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVG95LnN2ZWx0ZSJdfQ== */');
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i].store;
  child_ctx[7] = list[i].label;
  child_ctx[9] = i;
  return child_ctx;
}
function create_each_block4(ctx) {
  let toygroup;
  let current;
  toygroup = new ToyGroup_default({
    props: {
      isOpen: (
        /*index*/
        ctx[9] === 0
      ),
      store: (
        /*store*/
        ctx[6]
      ),
      label: (
        /*label*/
        ctx[7]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(toygroup.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(toygroup.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(toygroup, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(toygroup.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toygroup.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toygroup, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(18:2) {#each data as { store, label }",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let div;
  let div_class_value;
  let current;
  let each_value = (
    /*data*/
    ctx[3]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = null_to_empty(`state-mang ${/*theme*/
      ctx[2]}`) + " svelte-1wrwowr");
      add_location(div, file4, 16, 1, 391);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*data*/
      8) {
        each_value = /*data*/
        ctx2[3];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*theme*/
      4 && div_class_value !== (div_class_value = null_to_empty(`state-mang ${/*theme*/
      ctx2[2]}`) + " svelte-1wrwowr")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(16:0) <SideMenu {theme} {nub} {top} links={[]}>",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let sidemenu;
  let current;
  sidemenu = new SideMenu_default({
    props: {
      theme: (
        /*theme*/
        ctx[2]
      ),
      nub: (
        /*nub*/
        ctx[1]
      ),
      top: (
        /*top*/
        ctx[0]
      ),
      links: [],
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(sidemenu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(sidemenu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(sidemenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const sidemenu_changes = {};
      if (dirty & /*theme*/
      4)
        sidemenu_changes.theme = /*theme*/
        ctx2[2];
      if (dirty & /*nub*/
      2)
        sidemenu_changes.nub = /*nub*/
        ctx2[1];
      if (dirty & /*top*/
      1)
        sidemenu_changes.top = /*top*/
        ctx2[0];
      if (dirty & /*$$scope, theme*/
      1028) {
        sidemenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sidemenu.$set(sidemenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sidemenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sidemenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(sidemenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toy", slots, []);
  let { top = "10%" } = $$props;
  let { register } = $$props;
  let { nub = "🧰" } = $$props;
  let { theme = "" } = $$props;
  let keys = Object.keys(register);
  let data = keys.map((key) => {
    return { label: key, store: register[key] };
  });
  $$self.$$.on_mount.push(function() {
    if (register === void 0 && !("register" in $$props || $$self.$$.bound[$$self.$$.props["register"]])) {
      console.warn("<Toy> was created without expected prop 'register'");
    }
  });
  const writable_props = ["top", "register", "nub", "theme"];
  Object_13.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Toy> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("top" in $$props2)
      $$invalidate(0, top = $$props2.top);
    if ("register" in $$props2)
      $$invalidate(4, register = $$props2.register);
    if ("nub" in $$props2)
      $$invalidate(1, nub = $$props2.nub);
    if ("theme" in $$props2)
      $$invalidate(2, theme = $$props2.theme);
  };
  $$self.$capture_state = () => ({
    ToyGroup: ToyGroup_default,
    SideMenu: SideMenu_default,
    top,
    register,
    nub,
    theme,
    keys,
    data
  });
  $$self.$inject_state = ($$props2) => {
    if ("top" in $$props2)
      $$invalidate(0, top = $$props2.top);
    if ("register" in $$props2)
      $$invalidate(4, register = $$props2.register);
    if ("nub" in $$props2)
      $$invalidate(1, nub = $$props2.nub);
    if ("theme" in $$props2)
      $$invalidate(2, theme = $$props2.theme);
    if ("keys" in $$props2)
      keys = $$props2.keys;
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [top, nub, theme, data, register];
}
var Toy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { top: 0, register: 4, nub: 1, theme: 2 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toy",
      options,
      id: create_fragment4.name
    });
  }
  get top() {
    throw new Error("<Toy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<Toy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get register() {
    throw new Error("<Toy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set register(value) {
    throw new Error("<Toy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nub() {
    throw new Error("<Toy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nub(value) {
    throw new Error("<Toy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Toy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Toy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toy_default = Toy;
export {
  Toy_default as Toy
};
//# sourceMappingURL=@leveluptuts_svelte-toy.js.map
